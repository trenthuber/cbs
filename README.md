# cbs

Many modern programming languages integrate some form of a build system into their own runtimes, allowing developers to use the same language to write their applications and to build them. This library hopes to bring that functionality to the C language.

cbs is a build system for C projects and is itself written in C. This gives the added bonus of only needing a C compiler to build and compile C projects.

## Overview

Build "scripts" are written in files called `build.c`. Here is an example of the contents of such a file:

```c
#define CFLAGS ""
#define LFLAGS ""

#include "cbs.c"

int main(void) {
	build(NULL);

	compile("main", NULL);
	load('x', "main", "main", NULL);

	return 0;
}
```

To build your project, you first need to compile and run `build.c`. The inclusion of the `build(NULL);` statement at the top of the build file will recompile `build.c` every subsequent time you run it (see the [Recursive builds](#recursive-builds) section for details). This allows you to make changes to the build file without having to manually recompile.

```console
$ cc -o build build.c
$ ./build
cc -c -o main.o main.c                                                                                                                   
cc -o main main.o
$ ./main
Hello, world!
```

## Detailed usage

The advantage of making a build system that only compiles C projects is that it can be made dead simple. C code just needs to be compiled and linked, and perhaps it would be nice to recurse the build into subdirectories. cbs uses three simple functions accordingly: [`compile()`](#compiling) for compiling, [`load()`](#linking) for linking, and [`build()`](#recursive-builds) for recursion.

### Preprocessing

Before you include `cbs.c` it is important you define the `CFLAGS` and `LFLAGS` macros. `CFLAGS` gets passed to the compiler and `LFLAGS` gets passed to the linker. If you have no use for one or both of the flags, then they must be left as empty strings. Any flags you want to pass to the compiler or linker must be written as a comma separated list of C strings with no trailing comma, for example:

```c
#define CFLAGS "-Ifoo/", "-Ibar/", "-Dbaz"
#define LFLAGS "-lm", "-Llib/"
```

The `CFLAGS` and `LFLAGS` macros will automatically be used in all `compile()` and `load()` calls respectively.

### Compiling

```c
void compile(char *name, ...);
```

The `compile()` function is given a single source file to compile. File extensions are redundant and thus implicit in cbs, so don't use them. cbs will generate an object file of the same name and in the same directory as the source file you give it (notice this gives us the ability to reuse the list of source file names as object file names for the linker).[^1]

[^1]: Notice if we put the list of comma separated C strings in a macro, then we can pass it both to function calls and to array initialization. Using them in a null terminated array allows us to iterate through the array for names of source files to compile, while using the macro in a function call allows us to link all the object files generated by the compilation. This is the elegance of dropping the file extensions.

`compile()` will only run if it finds the source file has been modified since the last time it compiled the resulting object file. This is similar to the caching behavior in most other build systems.

If the object file also depends on other header files and you wish to trigger recompilation should the headers change, you can add their names (again, no extensions) after the name of the source file.

An example of compiling `main.c` which depends on `foo.h` and `bar.h`. This function call will produce the file `main.o`:

```c
compile("main", "foo", "bar", NULL);
```

It should be noted too that due to variatics in C, `compile()` requires a terminating null pointer in all cases.

### Linking

```c
void load(char type, char *output, char *input, ...);
```

The first argument to `load()`[^2] is the type of file to link. The options are:

[^2]: Although the term "linking" is far more common to use nowadays, the original term when UNIX was first created was "loading," so I use it here to name the function that does the linking. Also the name "link" is already taken on UNIX based systems.

```
'x' - executable
's' - statically linked library
'd' - dynamically linked library
```

The second argument is the name of the output. As mentioned above, the system will automatically add the correct file extension so there's no need to provide one. It is also common to prepend `lib` to files that are static or dynamic libraries; this is similarly done automatically, so you don't need to include it when naming the libraries (this is even considered when the name of the library is prepended by a path). This allows you to use the same name to refer to the library as you would when passing it to the linker's `-l` flag.

The rest of the arguments are the names of the files you want to link together (at least one is required). All files are assumed to be object files (static and dynamic libraries are linked through the linker's aforementioned `-l` flag).

An example of linking `a.o`, `libB.a`, and `c.o` into a static library, `libmain.a`:

```c
#define LFLAGS "-lB"
...
load('s', "main", "a", "c", NULL);
```

For the same reason as `compile()`, the `load()` function requires a null pointer as the last argument.

### Recursive builds

```c
void build(char *path);
```

It is often adventagous to compartmentalize projects into a number of subdirectories both for organizational purposes and for rebuilding parts at a time without rebuilding the whole thing. The usual way this is done is by placing build scripts in any subdirectory you want to rebuild on its own. But when it comes time for the overall build, we need a way to have the main build script call all the other ones (among other things). This is what the `build()` function is used for.

`build()` gets passed the name of the subdirectory you want to build. The path can be either absolute or relative to the directory the current build executable is being run in. This directory you pass it must have a `build.c` file in it which will be compiled (recompiled if needed) and ran. If `NULL` is passed to build, this has the effect of not switching directories and just recompiling (if necessary) and rerunning (if necessary) the build executable in the current directory. This is why we include `build(NULL);` at the start of build files we want to automatically recompile.

An example of building the contents of the directories `abc/src/` and `/usr/local/proj/src/`:

```c
build("abc/src/");
build("/usr/local/proj/src/");
```
